using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Logging.SmartStandards.Textualization;

// This file was generated by SmartStandards.Logging.tt at 19.04.2025
// Source Files were downloaded from: https://github.com/SmartStandards/Logging


// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Textualization/LogParaphRenderer.Minimum.cs


namespace Logging.SmartStandards.Textualization {

  // This is the minimum portion of LogParaphRenderer (which is included by SmartStandards.Logging.tt)


  internal partial class LogParaphRenderer {

    /// <summary>
    ///   Renders the right part of a log paraph.
    /// </summary>
    /// <remarks>
    ///   The right part contains meta data that cannot be transported as arguments, because most logging APIs do not offer enough
    ///   parameters.
    /// </remarks>
    /// <returns>
    ///   S.th. like " 2070198253252296432 [Ins]: File not found on Disk! "
    /// </returns>
    public static StringBuilder BuildParaphRightPart(
      StringBuilder targetStringBuilder, long sourceLineId, string audienceToken, string messageTemplate
    ) {
      targetStringBuilder.Append(' ');
      targetStringBuilder.Append(sourceLineId);
      targetStringBuilder.Append(" [");
      targetStringBuilder.Append(audienceToken);
      targetStringBuilder.Append("]: ");
      targetStringBuilder.Append(messageTemplate);
      return targetStringBuilder;
    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Transport/TraceBusFeed.cs


namespace Logging.SmartStandards.Transport {

  /// <summary>
  ///   Helper partial class for emitting messages into the (legacy) .NET System.Diagnostics.Trace concept
  /// </summary>

  internal partial class TraceBusFeed {

    private Dictionary<string, TraceSource> _TraceSourcePerSourceContext = new Dictionary<string, TraceSource>();

    private MyCircularBuffer<QueuedEvent> _EarlyPhaseBuffer;

    private readonly object _BufferManipulating = new object();

    private static TraceBusFeed _Instance;

    private bool _PatienceExercised;

    public static TraceBusFeed Instance {
      get {

        if (_Instance == null) {
          _Instance = new TraceBusFeed();
          _Instance._EarlyPhaseBuffer = new MyCircularBuffer<QueuedEvent>(1000);
        }

        return _Instance;
      }
    }

    private bool ListenersAvailable {
      get {

        if (Trace.Listeners.Count == 0) return false;

        if (Trace.Listeners.Count == 1) {
          string listenerName = Trace.Listeners[0].Name;
          if (listenerName == "Default") return false;
          if (this.IgnoredListeners.Contains(listenerName)) return false;
        }

        return true;
      }
    }

    public HashSet<string> IgnoredListeners { get; set; } = new HashSet<string>();

    private TraceSource GetTraceSourcePerSourceContext(string sourceContext) {

      lock (_TraceSourcePerSourceContext) {

        TraceSource traceSource = null;

        // get or (lazily) create TraceSource

        if (!_TraceSourcePerSourceContext.TryGetValue(sourceContext, out traceSource)) {

          // Optimization: Do not instantiate a TraceSource if there are no listeners:
          if (!this.ListenersAvailable) return null;

          // Instantiate a TraceSource:
          traceSource = new TraceSource(sourceContext);
          traceSource.Switch.Level = SourceLevels.All;

          _TraceSourcePerSourceContext[sourceContext] = traceSource;

          // when a new trace source was created => always keep all listeners of all TraceSource in sync:

          this.RewireAllSourcesAndListeners();
        }

        return traceSource;
      } // lock
    }

    private void FlushAndShutDownBuffer() {

      lock (_TraceSourcePerSourceContext) {

        if (_EarlyPhaseBuffer == null) return;

        MyCircularBuffer<QueuedEvent> earlyPhaseBuffer = _EarlyPhaseBuffer;
        _EarlyPhaseBuffer = null; // set field to null to avoid unwanted recursion

        foreach (QueuedEvent e in earlyPhaseBuffer) {
          TraceSource traceSource = this.GetTraceSourcePerSourceContext(e.SourceContext);
          traceSource?.TraceEvent(e.EventType, e.KindId, e.MessageTemplate, e.Args);
        }
      }
    }

    private void RewireAllSourcesAndListeners() {

      TraceSource firstTraceSource = null;

      bool awaitedListenerFound = false;

      foreach (KeyValuePair<string, TraceSource> namedTraceSource in _TraceSourcePerSourceContext) {

        if (firstTraceSource == null) {

          firstTraceSource = namedTraceSource.Value;

          firstTraceSource.Listeners.Clear();

          // Cherry-pick available listeners => store into the first TraceSource (representative of all others)

          awaitedListenerFound = this.CaptureListenersInto(firstTraceSource);

        } else { // subsequent trace sources get the same listeners as the first one
          namedTraceSource.Value.Listeners.Clear();
          namedTraceSource.Value.Listeners.AddRange(firstTraceSource.Listeners);
        }

      } // next namedTraceSource

      if (_EarlyPhaseBuffer != null && awaitedListenerFound) {
        this.FlushAndShutDownBuffer();
      }

    }

    private bool CaptureListenersInto(TraceSource targetTraceSource) {

      bool awaitedListenerFound = false;

      foreach (TraceListener listener in Trace.Listeners) {

        if (listener.Name == "Default") continue; // The .NET Default listener is a major performance hit => do not support.

        if (this.IgnoredListeners.Contains(listener.Name)) continue;

        targetTraceSource?.Listeners.Add(listener);

        if (listener.Name == "SmartStandards395316649") awaitedListenerFound = true;
      }

      return awaitedListenerFound;
    }

    public void EmitException(string audience, int level, string sourceContext, long sourceLineId, int kindId, Exception ex) {
      this.EmitMessage(audience, level, sourceContext, sourceLineId, kindId, ex.Message, new object[] { ex });
    }

    private void KillBufferAfterGracePeriod() {

      Thread.Sleep(10000);

      lock (_TraceSourcePerSourceContext) {

        bool awaitedListenerFound = this.CaptureListenersInto(null);

        if (awaitedListenerFound) this.FlushAndShutDownBuffer();

        _EarlyPhaseBuffer = null;
      }
    }

    /// <param name="level">
    ///   5 Critical
    ///   4 Error
    ///   3 Warning
    ///   2 Info
    ///   1 Debug
    ///   0 Trace
    /// </param>
    public void EmitMessage(
      string audience, int level, string sourceContext, long sourceLineId,
      int kindId, string messageTemplate, params object[] args
    ) {

      if (!_PatienceExercised) {
        _PatienceExercised = true;
        Task.Run(this.KillBufferAfterGracePeriod);
      }

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      TraceSource traceSource = this.GetTraceSourcePerSourceContext(sourceContext);

      if (traceSource is null && _EarlyPhaseBuffer == null) return;

      if (string.IsNullOrWhiteSpace(audience)) audience = "Dev";

      if (messageTemplate == null) messageTemplate = "";

      TraceEventType eventType;

      switch (level) {

        case 5: { // Critical (aka "Fatal")
          eventType = TraceEventType.Critical; // 1
          break;
        }

        case 4: { // Error
          eventType = TraceEventType.Error; // 2
          break;
        }

        case 3: { // Warning
          eventType = TraceEventType.Warning; // 4
          break;
        }

        case 2: { // Info
          eventType = TraceEventType.Information; // 8
          break;
        }

        case 1: { // Debug
          eventType = TraceEventType.Transfer; // 4096 - ' There is no "Debug" EventType => use something else
                                               // 0 "Trace" (aka "Verbose")
          break;
        }

        default: { // Trace
          eventType = TraceEventType.Verbose; // 16
          break;
        }

      }

      // Because we support named placeholders (like "Hello {person}") instead of old scool indexed place holders
      // (like "Hello {0}") we need to double brace the placeholders - otherwise there will be exceptions coming from
      // the .net TraceEvent Method.

      StringBuilder formatStringBuilder = new StringBuilder(messageTemplate.Length + 20);

      LogParaphRenderer.BuildParaphRightPart(formatStringBuilder, sourceLineId, audience, messageTemplate);

      formatStringBuilder.Replace("{", "{{").Replace("}", "}}");

      // actual emit

      traceSource?.TraceEvent(eventType, kindId, formatStringBuilder.ToString(), args);

      if (_EarlyPhaseBuffer != null) {
        _EarlyPhaseBuffer.SafeEnqueue(new QueuedEvent(sourceContext, eventType, kindId, formatStringBuilder.ToString(), args));
      }

    }

    private partial class QueuedEvent {

      public string SourceContext;

      public TraceEventType EventType { get; set; }

      public int KindId { get; set; }

      public string MessageTemplate { get; set; }

      public object[] Args { get; set; }

      public QueuedEvent(string sourceContext, TraceEventType EventType, int kindId, string messageTemplate, object[] args) {
        SourceContext = sourceContext;
        this.EventType = EventType;
        this.KindId = kindId;
        this.MessageTemplate = messageTemplate;
        this.Args = args;
      }

    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Transport/TraceBusFeed.Buffer.cs


namespace Logging.SmartStandards.Transport {


  internal partial class TraceBusFeed {

    /// <remarks>
    ///   Taken from https://stackoverflow.com/a/5924776
    /// </remarks>
    private partial class MyCircularBuffer<T> : IEnumerable<T> {

      readonly int _Size;

      readonly object _Locker;

      int _Count;
      int _Head;
      int _Rear;
      T[] _Values;

      public MyCircularBuffer(int max) {
        _Size = max;
        _Locker = new object();
        _Count = 0;
        _Head = 0;
        _Rear = 0;
        _Values = new T[_Size];
      }

      static int Incr(int index, int size) {
        return (index + 1) % size;
      }

      public object SyncRoot { get { return _Locker; } }

      public void SafeEnqueue(T obj) {
        lock (_Locker) { this.UnsafeEnqueue(obj); }
      }

      public void UnsafeEnqueue(T obj) {

        _Values[_Rear] = obj;

        if (_Count == _Size) _Head = Incr(_Head, _Size);

        _Rear = Incr(_Rear, _Size);
        _Count = Math.Min(_Count + 1, _Size);
      }

      public IEnumerator<T> GetEnumerator() {
        int index = _Head;

        for (int i = 0; i < _Count; i++) {
          yield return _Values[index];
          index = Incr(index, _Size);
        }

      }

      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
        return this.GetEnumerator();
      }

    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Internal/ExceptionAnalyzer.cs


namespace Logging.SmartStandards.Internal {

  internal partial class ExceptionAnalyzer {

    internal static int InferEventKindByException(Exception ex) {

      // 'Zwiebel' durch Aufrufe via Reflection (InnerException ist mehr repräsentativ)

      if (ex is TargetInvocationException && ex.InnerException != null) {
        return InferEventKindByException(ex.InnerException);
      }

      // 'Zwiebel' durch Task.Run (InnerException ist mehr repräsentativ)

      if (ex is AggregateException) {
        AggregateException castedAggregateException = (AggregateException)ex;
        if (
          castedAggregateException.InnerExceptions != null &&
          castedAggregateException.InnerExceptions.Count == 1 //falls nur 1 enthalten (macht MS gern)
        ) {
          return InferEventKindByException(castedAggregateException.InnerExceptions[0]);
        }
      }

      // An einer Win32Exception hängt i.d.R. bereits eine kindId => diese verwenden

      if (ex is Win32Exception) {
        return ((Win32Exception)ex).NativeErrorCode;
      }

      // Falls der Absender die Konvention "MessageText #{kindId}" einhielt...

      int hashTagIndex = ex.Message.LastIndexOf('#');

      if (hashTagIndex >= 0 && int.TryParse(ex.Message.Substring(hashTagIndex + 1), out int id)) {
        return id;
      }

      // 'Zwiebel' durch Exception.Wrap (InnerException ist mehr repräsentativ)

      if (ex is ExceptionExtensions.WrappedException) {
        return InferEventKindByException(ex.InnerException);
      }

      // Fallback zuletzt: Wir leiten aus dem Exception-Typ eine kindId ab.

      using (var md5 = MD5.Create()) {
        int hash = BitConverter.ToInt32(md5.ComputeHash(Encoding.UTF8.GetBytes(ex.GetType().Name)), 0);
        if (hash < 0) {
          return hash * -1;
        }
        return hash;
      }

    }

  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/DevLogger.PerLevel.cs


namespace Logging.SmartStandards {


  internal partial class DevLogger {

    public static void LogTrace(string sourceContext, long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      Log(0, sourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Enum templateEnumElement, params object[] args) {
      Log(0, sourceContext, sourceLineId, templateEnumElement, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Exception ex) {
      Log(0, sourceContext, sourceLineId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      Log(1, sourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Enum templateEnumElement, params object[] args) {
      Log(1, sourceContext, sourceLineId, templateEnumElement, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Exception ex) {
      Log(1, sourceContext, sourceLineId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      Log(2, sourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Enum templateEnumElement, params object[] args) {
      Log(2, sourceContext, sourceLineId, templateEnumElement, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Exception ex) {
      Log(2, sourceContext, sourceLineId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      Log(3, sourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Enum templateEnumElement, params object[] args) {
      Log(3, sourceContext, sourceLineId, templateEnumElement, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Exception ex) {
      Log(3, sourceContext, sourceLineId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      Log(4, sourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, Enum templateEnumElement, params object[] args) {
      Log(4, sourceContext, sourceLineId, templateEnumElement, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, Exception ex) {
      Log(4, sourceContext, sourceLineId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      Log(5, sourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Enum templateEnumElement, params object[] args) {
      Log(5, sourceContext, sourceLineId, templateEnumElement, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Exception ex) {
      Log(5, sourceContext, sourceLineId, ex);
    }
  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/DevLogger.WoSourceContext.cs


namespace Logging.SmartStandards {


  internal partial class DevLogger {

    // NOTE: [MethodImpl(MethodImplOptions.NoInlining)]
    // is used to avoid wrong results from Assembly.GetCallingAssembly()

    #region MessageTemplate only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, 0, messageTemplate, args);
    }

    #endregion

    #region templateEnumElement only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, templateEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, templateEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, templateEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, templateEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, templateEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, templateEnumElement, args);
    }

    #endregion

    #region Exception only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, ex);
    }

    #endregion

    #region Ids and MessageTemplate

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int kindId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    #endregion

    #region Ids and templateEnumElement

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, templateEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, templateEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, templateEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, templateEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, templateEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Enum templateEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, templateEnumElement, args);
    }

    #endregion

    #region SourceLineId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, ex);
    }

    #endregion

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/ExceptionExtensions.cs


namespace Logging.SmartStandards {


  internal static partial class ExceptionExtensions {

    /// <summary>
    ///   Puts your envelope exception around an exception coming from elsewhere.
    /// </summary>
    /// <param name="extendee"> The 3rd party exception (becoming the inner exception). </param>
    /// <param name="message"> Your message adding value to the 3rd party exception. </param>
    /// <returns> A new WrappedException instance containing the extendee as inner exception. </returns>
    /// <remarks>
    ///   Purpose: The 3rd party exception might be generic (like null reference, etc.) and thus not very helpful.
    ///   Add specific information (like IDs etc.) in to the envelope's message.
    /// </remarks>
    public static Exception Wrap(this Exception extendee, string message) { // REQ #395397931

      WrappedException wrappedException = new WrappedException(message, extendee);

      return wrappedException;
    }

    /// <summary>
    ///   Puts your envelope exception around an exception coming from elsewhere.
    /// </summary>
    /// <param name="extendee"> The 3rd party exception (becoming the inner exception). </param>
    /// <param name="kindId"> Will be added as #-suffix to the message (SmartStandards compliant parsable). </param>
    /// <param name="message"> Your message adding value to the 3rd party exception. </param>
    /// <returns> A new WrappedException instance containing the extendee as inner exception. </returns>
    /// <remarks>
    ///   Purpose: The 3rd party exception might be generic (like null reference, etc.) and thus not very helpful.
    ///   Add specific information (like IDs etc.) in to the envelope's message.
    /// </remarks>
    public static Exception Wrap(this Exception extendee, int kindId, string message) { // REQ #395397931

      WrappedException wrappedException = new WrappedException(message + " #" + kindId.ToString(), extendee);

      return wrappedException;
    }

    internal partial class WrappedException : Exception {

      public WrappedException(string message, Exception inner) : base(message, inner) {
      }

    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/TemplateHousekeeping/LogEventTemplateEnumConverter.cs


namespace Logging.SmartStandards.TemplateHousekeeping {


  internal partial class LogEventTemplateEnumConverter : EnumConverter {

    private Array _FlagValues;

    private bool _IsFlagEnum = false;

    private Dictionary<CultureInfo, Dictionary<string, object>> _CachesPerLanguage = new Dictionary<CultureInfo, Dictionary<string, object>>();

    public LogEventTemplateEnumConverter(Type enumType) : base(enumType) {
      if (enumType.GetCustomAttributes(typeof(FlagsAttribute), true).Any()) {
        _IsFlagEnum = true;
        _FlagValues = Enum.GetValues(enumType);
      }
    }

    public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

      if (value is string) {
        object result;

        if (_IsFlagEnum) {
          result = this.GetMessageTemplateFromAttributeByEnumFlag(culture, (string)value);
        } else {
          result = this.GetMessageTemplateFromCache(culture, (string)value);
        }

        if (result == null) {
          if (value != null) {
            result = base.ConvertFrom(context, culture, value);
          }
        }

        return result;
      }

      return base.ConvertFrom(context, culture, value);
    }

    public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {

      // at system.xaml.dll

      if (context == null || !(context.GetType().FullName.Equals("System.Windows.Markup.IValueSerializerContext"))) {
        if ((value != null) && (destinationType.Equals(typeof(System.String)))) {
          object result;
          if ((_IsFlagEnum)) {
            result = this.GetMessageTemplateFromAttributeByEnumFlagValue(culture, value);
          } else {
            result = this.GetMessageTemplateFromAttributeByEnumValue(culture, value);
          }
          return result;
        }
      }

      return base.ConvertTo(context, culture, value, destinationType);
    }

    public static string ConvertToString(Enum value) {
      if (value != null) {
        TypeConverter converter = TypeDescriptor.GetConverter(value.GetType());
        return converter.ConvertToString(value);
      }
      return string.Empty;
    }

    private object GetMessageTemplateFromAttributeByEnumFlag(CultureInfo culture, string text) {
      Dictionary<string, object> languageSpecificCache = this.GetLanguageSpecificCache(culture);
      string[] textValues = text.Split(',');
      ulong result = 0;

      foreach (string textValue in textValues) {
        object value = null;
        string trimmedTextValue = textValue.Trim();

        if ((!languageSpecificCache.TryGetValue(trimmedTextValue, out value)))
          return null;

        result = result | Convert.ToUInt32(value);
      }

      return Enum.ToObject(this.EnumType, result);
    }

    private Dictionary<string, object> GetLanguageSpecificCache(CultureInfo culture) {
      lock (_CachesPerLanguage) {
        Dictionary<string, object> result = null;
        if (culture == null) {
          culture = CultureInfo.CurrentCulture;
        }
        if (!_CachesPerLanguage.TryGetValue(culture, out result)) {
          result = new Dictionary<string, object>();
          foreach (var value in this.GetStandardValues()) {
            var text = this.GetMessageTemplateFromAttributeByEnumValue(culture, value);
            if (text != null) {
              result.Add(text, value);
            }
          }
          _CachesPerLanguage.Add(culture, result);
        }
        return result;
      }
    }

    private object GetMessageTemplateFromCache(CultureInfo culture, string text) {
      Dictionary<string, object> languageSpecificCache = this.GetLanguageSpecificCache(culture);
      object result = null;
      languageSpecificCache.TryGetValue(text, out result);
      return result;
    }

    private string GetMessageTemplateFromAttributeByEnumValue(CultureInfo culture, object value) {

      if (value == null) {
        return string.Empty;
      }

      Type type = value.GetType();

      if (!type.IsEnum) {
        return value.ToString();
      }

      LogEventTemplateAttribute[] attributes = this.GetEnumFieldAttributes<LogEventTemplateAttribute>((Enum)value);

      LogEventTemplateAttribute defaultAttribute = attributes.FirstOrDefault();

      foreach (LogEventTemplateAttribute attribute in attributes) {
        if (string.IsNullOrEmpty(attribute.Language)) {
          defaultAttribute = attribute;
        } else if (attribute.Language.Equals(culture.Name, StringComparison.InvariantCultureIgnoreCase)) {
          return attribute.LogMessageTemplate;
        }
      }
      if (defaultAttribute != null) {
        return defaultAttribute.LogMessageTemplate;
      } else {
        return Enum.GetName(type, value);
      }
    }

    private string GetMessageTemplateFromAttributeByEnumFlagValue(CultureInfo culture, object value) {
      if (Enum.IsDefined(value.GetType(), value)) {
        return this.GetMessageTemplateFromAttributeByEnumValue(culture, value);
      }
      long lValue = Convert.ToInt32(value);
      string result = null;
      foreach (object flagValue in _FlagValues) {
        long lFlagValue = Convert.ToInt32(flagValue);
        if (this.CheckSingleBit(lFlagValue)) {
          if ((lFlagValue & lValue) == lFlagValue) {
            string valueText = this.GetMessageTemplateFromAttributeByEnumValue(culture, flagValue);
            if (result == null) {
              result = valueText;
            } else {
              result = string.Format("{0}+{1}", result, valueText);
            }
          }
        }
      }

      return result;
    }

    public static List<KeyValuePair<Enum, string>> GetValues(Type enumType) {
      return GetValues(enumType, CultureInfo.CurrentUICulture);
    }

    public static List<KeyValuePair<Enum, string>> GetValues(Type enumType, CultureInfo culture) {
      List<KeyValuePair<Enum, string>> result = new List<KeyValuePair<Enum, string>>();
      TypeConverter converter = TypeDescriptor.GetConverter(enumType);
      foreach (System.Enum value in Enum.GetValues(enumType)) {
        KeyValuePair<Enum, string> pair = new KeyValuePair<Enum, string>(
          value, converter.ConvertToString(null, culture, value)
        );
        result.Add(pair);
      }
      return result;
    }

    private bool CheckSingleBit(long value) {
      switch (value) {
        case 0: {
          return false;
        }
        case 1: {
          return true;
        }
      }
      return ((value & (value - 1)) == 0);
    }

    private TAttribute[] GetEnumFieldAttributes<TAttribute>(Enum enumValue) where TAttribute : Attribute {
      Type enumType = enumValue.GetType();
      string enumFieldName = Enum.GetName(enumType, enumValue);
      if ((enumFieldName == null))
        return new TAttribute[] { };
      else {
        FieldInfo enumField = enumType.GetField(enumFieldName);
        return enumField.GetCustomAttributes(false).OfType<TAttribute>().ToArray();
      }
    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/TemplateHousekeeping/LogEventTemplateAttribute.cs


namespace Logging.SmartStandards.TemplateHousekeeping {

  /// <summary>
  ///   Defines a log message template for an enum value (representing the log event kind id).
  /// </summary>
  [AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]

  internal partial class LogEventTemplateAttribute : Attribute {

    /// <summary>
    ///  Constructor.
    /// </summary>
    /// <param name="logMessageTemplate"></param>
    /// <param name="language"> ISO code like 'en-us' or 'de-de' </param>
    public LogEventTemplateAttribute(string logMessageTemplate, string language = null) {
      this.LogMessageTemplate = logMessageTemplate;
      this.Language = language;
    }

    public string LogMessageTemplate { get; }

    public string Language { get; }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/TemplateHousekeeping/LogEventTemplateRepository.cs


namespace Logging.SmartStandards.TemplateHousekeeping {


  internal static partial class LogEventTemplateRepository {

    internal static void GetMessageTemplateByKind(Enum templateEnumElement, out int kindId, out string messageTemplate) {

      kindId = (int)(object)templateEnumElement;

      messageTemplate = null;

      try {
        TypeConverter typeConverter = TypeDescriptor.GetConverter(templateEnumElement);
        if (typeConverter != null && typeConverter.CanConvertTo(typeof(System.String))) {
          messageTemplate = typeConverter.ConvertToString(templateEnumElement);
        }
      } catch {
      }
      if (String.IsNullOrWhiteSpace(messageTemplate)) {
        messageTemplate = Enum.GetName(templateEnumElement.GetType(), templateEnumElement);
      }
    }

  }
}


namespace Logging.SmartStandards {

  internal partial class DevLogger {

    public const string AudienceToken = "Dev";

    public static void Log(
      int level, string sourceContext, long sourceLineId, int kindId, string messageTemplate, params object[] args
    ) {

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (messageTemplate == null) messageTemplate = "";

      if (args == null) args = new object[0];

      Logging.SmartStandards.Transport.TraceBusFeed.Instance.EmitMessage(AudienceToken, level, sourceContext, sourceLineId, kindId, messageTemplate, args);

    }

    public static void Log(int level, string sourceContext, long sourceLineId, Enum templateEnumElement, params object[] args) {
      TemplateHousekeeping.LogEventTemplateRepository.GetMessageTemplateByKind(templateEnumElement, out int kindId, out string messageTemplate);
      Log(level, sourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, Exception ex) {
      int kindId = Logging.SmartStandards.Internal.ExceptionAnalyzer.InferEventKindByException(ex);
      Logging.SmartStandards.Transport.TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, kindId, ex);
    }

  }
}

