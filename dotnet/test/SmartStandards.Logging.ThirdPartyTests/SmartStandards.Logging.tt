<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 

// This template allows to use logging (into .NET trace) in SmartStandards compliant manner without using NuGet 
// packages.
// Sources will directly be downloaded from git and aggregated into one monolithic .cs file.

string ttVersion = "1.0.0"; // (compatible with SmartStandards.Logging 2.4.1)

string projectUrl = "https://github.com/SmartStandards/Logging";

string repositoryRootUrl = "https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/";

string[] fileDownloadUrls = new string[] {

  "Logging/SmartStandards/Textualization/LogParaphRenderer.Minimum.cs",
  "Logging/SmartStandards/Transport/TraceBusFeed.cs",
  "Logging/SmartStandards/Transport/TraceBusFeed.Buffer.cs",

  "Logging/SmartStandards/Internal/ExceptionAnalyzer.cs",
  "Logging/SmartStandards/DevLogger.PerLevel.cs",
  "Logging/SmartStandards/DevLogger.WoSourceContext.cs",

  "Logging/SmartStandards/ExceptionExtensions.cs",
  
  "Logging/SmartStandards/TemplateHousekeeping/LogEventTemplateEnumConverter.cs",
  "Logging/SmartStandards/TemplateHousekeeping/LogEventTemplateRepository.cs",
  "Logging/SmartStandards/TemplateHousekeeping/LogMessageTemplateAttribute.cs",
   
};

string content;

string currentFileUrl = "";

try {

  StringBuilder aggregatedContent = new StringBuilder(10000);

  List<string> usings = new List<string>();

  aggregatedContent.AppendLine();
  aggregatedContent.Append("// This file was generated by SmartStandards.Logging.tt v ");
  aggregatedContent.Append(ttVersion);
  aggregatedContent.Append(" at ");
  aggregatedContent.AppendLine(DateTime.Now.ToShortDateString());
  aggregatedContent.Append("// Source Files were downloaded from: ");
  aggregatedContent.AppendLine(projectUrl);
  aggregatedContent.AppendLine();

  foreach (string fileDownloadUrl in fileDownloadUrls) {

    using (var wc = new System.Net.WebClient()) {

      currentFileUrl = repositoryRootUrl + fileDownloadUrl;

      string fileContent = wc.DownloadString(currentFileUrl);

      using (TextReader reader = new StringReader(fileContent)) {

        string currentLine = reader.ReadLine();

        aggregatedContent.AppendLine();
        aggregatedContent.Append("// Taken from File: ");
        aggregatedContent.AppendLine(currentFileUrl);
        aggregatedContent.AppendLine();

        while (currentLine != null) {
          if (currentLine.StartsWith("using")) {
            usings.Add(currentLine);
          } else if (currentLine.StartsWith("[assembly:")) {
            //skip
          } else {
            aggregatedContent.AppendLine(currentLine);
          }
          currentLine = reader.ReadLine();
        } // wend
      } // using TextReader
    } // using WebClient
  } // next fileDownloadUrl

  string sourceInfo = "Mirrored file from GitHub";
  string vers = DateTime.Now.ToShortDateString();
  string compilerGeneratedAttributes = ""; //"[CompilerGenerated()][GeneratedCode(tool:\"" + sourceInfo + "\", version:\"" + vers + "\")]";

  aggregatedContent = aggregatedContent.Replace("partial class", "class");
  aggregatedContent = aggregatedContent.Replace("public class", compilerGeneratedAttributes + "\n  internal class");
  aggregatedContent = aggregatedContent.Replace("public static class", compilerGeneratedAttributes + "\n  internal static class");
  aggregatedContent = aggregatedContent.Replace("public interface", compilerGeneratedAttributes + "\n  internal clinterfaceass");
  aggregatedContent = aggregatedContent.Replace("public static interface", compilerGeneratedAttributes + "\n  internal static interface");
  aggregatedContent = aggregatedContent.Replace("public enum", compilerGeneratedAttributes + "\n  internal enum");
  aggregatedContent = aggregatedContent.Replace("class", "partial class");
  aggregatedContent = aggregatedContent.Replace("partial partial", "partial");

  // usings
  
  aggregatedContent.Insert(0, string.Join("\r\n", usings.Distinct().OrderBy((u)=>u)) + "\r\n");
  aggregatedContent.ToString();

  content = aggregatedContent.ToString();
} catch (Exception ex) {
  content = "Error Processing '" + currentFileUrl + "': " + ex.Message;
}
#><#= content #>

namespace Logging.SmartStandards {
 
  internal partial class DevLogger {

    public const string AudienceToken = "Dev";

    public static void Log(
      int level, string sourceContext, long sourceLineId, int kindId, string messageTemplate, params object[] args
    ) {

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (messageTemplate == null) messageTemplate = "";

      if (args == null) args = new object[0];

      Logging.SmartStandards.Transport.TraceBusFeed.Instance.EmitMessage(AudienceToken, level, sourceContext, sourceLineId, kindId, messageTemplate, args);

    }

    public static void Log(int level, string sourceContext, long sourceLineId, Enum templateEnumElement, params object[] args) {
      TemplateHousekeeping.LogEventTemplateRepository.GetLogEventTemplateByEnum(templateEnumElement, out int kindId, out string messageTemplate);
      Log(level, sourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, Exception ex) {
      int kindId = Logging.SmartStandards.Internal.ExceptionAnalyzer.InferEventKindByException(ex);
      Logging.SmartStandards.Transport.TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, kindId, ex); 
    }

  }
}

