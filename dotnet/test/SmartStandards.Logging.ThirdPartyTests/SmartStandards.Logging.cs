using Logging.SmartStandards.Internal;
using Logging.SmartStandards.Textualization;
using Logging.SmartStandards.Transport;
using Logging.SmartStandards.UseCaseManagement;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

// This is a partial copy of the SmartStandards Logging Library.
// It is intended to be used as an alternative when including the NuGet package is not feasible.
// It offers reduced features: There is no custom routing, emitted log events always flow to the TraceBus.

// This file was generated by SmartStandards.Logging.tt v 1.0.0 at 16.05.2025
// Included sources were downloaded from: https://github.com/SmartStandards/Logging

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Textualization/LogParaphRenderer.Minimum.cs

namespace Logging.SmartStandards.Textualization {

  // This is the minimum portion of LogParaphRenderer (which is included by SmartStandards.Logging.tt)

  internal partial class LogParaphRenderer { // v 1.0.0

    /// <summary>
    ///   Renders the right part of a log paraph.
    /// </summary>
    /// <remarks>
    ///   The right part contains meta data that cannot be transported as arguments, because most logging APIs do not offer enough
    ///   parameters.
    /// </remarks>
    /// <returns>
    ///   S.th. like " 2070198253252296432 [Ins]: File not found on Disk! "
    /// </returns>
    public static StringBuilder BuildParaphRightPart(
      StringBuilder targetStringBuilder, long sourceLineId, string audienceToken, string messageTemplate
    ) {
      targetStringBuilder.Append(' ');
      targetStringBuilder.Append(sourceLineId);
      targetStringBuilder.Append(" [");
      targetStringBuilder.Append(audienceToken);
      targetStringBuilder.Append("]: ");
      targetStringBuilder.Append(messageTemplate);
      return targetStringBuilder;
    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Transport/TraceBusFeed.cs

namespace Logging.SmartStandards.Transport {

  /// <summary>
  ///   Helper partial class for emitting messages into the (legacy) .NET System.Diagnostics.Trace concept
  /// </summary>
  internal partial class TraceBusFeed { // v 1.0.0

    private MyCircularBuffer<QueuedEvent> _DebuggingLookBackBuffer;

    private static TraceBusFeed _Instance;

    public static TraceBusFeed Instance {
      get {

        if (_Instance == null) {
          _Instance = new TraceBusFeed();
        }

        return _Instance;
      }
    }

    public HashSet<string> IgnoredListeners { get; set; } = new HashSet<string>();

    public bool AutoFlush { get; set; } = true;

    private void FlushAndShutDownBuffer(TraceListener targetListener) {

      if (_DebuggingLookBackBuffer == null) return;

      lock (this) {

        _DebuggingLookBackBuffer.StopAutoFlush();

        foreach (QueuedEvent e in _DebuggingLookBackBuffer) {
          TraceEventCache eventCache = new TraceEventCache();
          InvokeListenerTraceEvent(targetListener, eventCache, e.EventType, e.SourceContext, e.UseCaseId, e.MessageTemplate, e.Args);
        }

        _DebuggingLookBackBuffer = null;
      }
    }

    /// <summary>
    ///   Helper to invoke the TraceEvent() method of a TraceListener the right way.
    ///   Identify the right overload and respect thread safety.
    /// </summary>
    private void InvokeListenerTraceEvent(
      TraceListener targetListener, TraceEventCache eventCache, TraceEventType eventType, string sourceContext, int id, string format, params object[] args
    ) {
      if (targetListener.IsThreadSafe) {
        if (args == null) {
          targetListener.TraceEvent(eventCache, sourceContext, eventType, id, format);
          if (this.AutoFlush) targetListener.Flush();
        } else {
          targetListener.TraceEvent(eventCache, sourceContext, eventType, id, format, args);
          if (this.AutoFlush) targetListener.Flush();
        }
      } else {
        lock (targetListener) {
          if (args == null) {
            targetListener.TraceEvent(eventCache, sourceContext, eventType, id, format);
            if (this.AutoFlush) targetListener.Flush();
          } else {
            targetListener.TraceEvent(eventCache, sourceContext, eventType, id, format, args);
            if (this.AutoFlush) targetListener.Flush();
          }
        }
      }
    }

    private void ToAllRelevantListeners(TraceEventType eventType, string sourceContext, int id, string format, params object[] args) {

      TraceEventCache eventCache = new TraceEventCache(); // same instance for many listeners

      ForEachRelevantListener(
        (TraceListener listener) => {
          InvokeListenerTraceEvent(listener, eventCache, eventType, sourceContext, id, format, args);
        }
      );
    }

    public void EmitException(string audience, int level, string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      this.EmitMessage(audience, level, sourceContext, sourceLineId, useCaseId, ex.Message, new object[] { ex });
    }

    private DefaultTraceListener ForEachRelevantListener(Action<TraceListener> onProcessListener) {

      DefaultTraceListener foundDefaultTraceListener = null;

      foreach (TraceListener listener in Trace.Listeners) {

        if (this.IgnoredListeners.Contains(listener.Name)) continue;

        DefaultTraceListener defaultTraceListener = listener as DefaultTraceListener; // try cast

        if (defaultTraceListener != null) {

          bool isLogging = Debugger.IsLogging();

          foundDefaultTraceListener = defaultTraceListener;

          if (_DebuggingLookBackBuffer != null && isLogging) FlushAndShutDownBuffer(defaultTraceListener);

          // Is the default logger EmittingWorthy?
          if (!isLogging && String.IsNullOrWhiteSpace(defaultTraceListener.LogFileName)) continue;
        }

        onProcessListener.Invoke(listener);

      }
      return foundDefaultTraceListener;
    }

    /// <param name="level">
    ///   5 Critical
    ///   4 Error
    ///   3 Warning
    ///   2 Info
    ///   1 Debug
    ///   0 Trace
    /// </param>
    public void EmitMessage(
      string audience, int level, string sourceContext, long sourceLineId,
      int useCaseId, string messageTemplate, params object[] args
    ) {

      // Performance: Do not prepare a message that is never sent (or buffered)

      bool emittingWorthyListenersExist = false;

      DefaultTraceListener foundDefaultTraceListener = null;

      foundDefaultTraceListener = ForEachRelevantListener((TraceListener listener) => { emittingWorthyListenersExist = true; });

      if (!Debugger.IsLogging() && foundDefaultTraceListener != null && _DebuggingLookBackBuffer == null) {

        _DebuggingLookBackBuffer = new MyCircularBuffer<QueuedEvent>(1000);

        _DebuggingLookBackBuffer.StartAutoFlush(() => { if (Debugger.IsLogging()) FlushAndShutDownBuffer(foundDefaultTraceListener); }, 3000);
      }

      if (!emittingWorthyListenersExist && _DebuggingLookBackBuffer == null) return;

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (string.IsNullOrWhiteSpace(audience)) audience = "Dev";

      if (messageTemplate == null) messageTemplate = "";

      TraceEventType eventType;

      switch (level) {

        case 5: { // Critical (aka "Fatal")
          eventType = TraceEventType.Critical; // 1
          break;
        }

        case 4: { // Error
          eventType = TraceEventType.Error; // 2
          break;
        }

        case 3: { // Warning
          eventType = TraceEventType.Warning; // 4
          break;
        }

        case 2: { // Info
          eventType = TraceEventType.Information; // 8
          break;
        }

        case 1: { // Debug
          eventType = TraceEventType.Transfer; // 4096 - ' There is no "Debug" EventType => use something else
                                               // 0 "Trace" (aka "Verbose")
          break;
        }

        default: { // Trace
          eventType = TraceEventType.Verbose; // 16
          break;
        }

      }

      // Because we support named placeholders (like "Hello {person}") instead of old scool indexed place holders
      // (like "Hello {0}") we need to double brace the placeholders - otherwise there will be exceptions coming from
      // the .net TraceEvent Method.

      StringBuilder formatStringBuilder = new StringBuilder(messageTemplate.Length + 20);

      LogParaphRenderer.BuildParaphRightPart(formatStringBuilder, sourceLineId, audience, messageTemplate);

      formatStringBuilder.Replace("{", "{{").Replace("}", "}}");

      // actual emit

      ToAllRelevantListeners(eventType, sourceContext, useCaseId, formatStringBuilder.ToString(), args);

      if (_DebuggingLookBackBuffer != null) {
        lock (this) {
          _DebuggingLookBackBuffer.UnsafeEnqueue(new QueuedEvent(sourceContext, eventType, useCaseId, formatStringBuilder.ToString(), args));
        }
      }

    }

    internal partial class QueuedEvent {

      public string SourceContext;

      public TraceEventType EventType { get; set; }

      public int UseCaseId { get; set; }

      public string MessageTemplate { get; set; }

      public object[] Args { get; set; }

      public QueuedEvent(string sourceContext, TraceEventType EventType, int useCaseId, string messageTemplate, object[] args) {
        SourceContext = sourceContext;
        this.EventType = EventType;
        this.UseCaseId = useCaseId;
        this.MessageTemplate = messageTemplate;
        this.Args = args;
      }

    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Transport/TraceBusFeed.Buffer.cs

namespace Logging.SmartStandards.Transport {

  internal partial class TraceBusFeed {

    /// <remarks>
    ///   Taken from https://stackoverflow.com/a/5924776
    /// </remarks>
    internal partial class MyCircularBuffer<T> : IEnumerable<T> { // v 1.0.0

      readonly int _Size;

      readonly object _Locker;

      int _Count;
      int _Head;
      int _Rear;
      T[] _Values;

      public MyCircularBuffer(int max) {
        _Size = max;
        _Locker = new object();
        _Count = 0;
        _Head = 0;
        _Rear = 0;
        _Values = new T[_Size];
      }

      static int Incr(int index, int size) {
        return (index + 1) % size;
      }

      public object SyncRoot { get { return _Locker; } }

      public void SafeEnqueue(T obj) {
        lock (_Locker) { this.UnsafeEnqueue(obj); }
      }

      public void UnsafeEnqueue(T obj) {

        _Values[_Rear] = obj;

        if (_Count == _Size) _Head = Incr(_Head, _Size);

        _Rear = Incr(_Rear, _Size);
        _Count = Math.Min(_Count + 1, _Size);
      }

      public IEnumerator<T> GetEnumerator() {
        int index = _Head;

        for (int i = 0; i < _Count; i++) {
          yield return _Values[index];
          index = Incr(index, _Size);
        }

      }

      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
        return this.GetEnumerator();
      }

      CancellationTokenSource _CancellationTokenSource = null;

      Action _OnFlush;

      public void StartAutoFlush(Action onFlush, int interval) {

        if (_CancellationTokenSource != null) return;

        _OnFlush = onFlush;

        _CancellationTokenSource = new CancellationTokenSource();

        CancellationToken ct = _CancellationTokenSource.Token;

        Task.Run(() => this.AutoFlushInfiniteLoop(interval, ct));
      }

      private void AutoFlushInfiniteLoop(int interval, CancellationToken ct) {
        while (!ct.IsCancellationRequested) {
          Thread.Sleep(interval);
          lock (_Locker) {
            _OnFlush.Invoke();
          }
        }
      }

      public void StopAutoFlush() {
        if (_CancellationTokenSource == null) return;
        _CancellationTokenSource.Cancel();
        _CancellationTokenSource.Dispose();
        _CancellationTokenSource = null;
      }

    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Internal/ExceptionAnalyzer.cs

namespace Logging.SmartStandards.Internal {

  internal partial class ExceptionAnalyzer { // v 1.0.0

    internal static int InferUseCaseIdByException(Exception ex) {

      // 'Zwiebel' durch Aufrufe via Reflection (InnerException ist mehr repräsentativ)

      if (ex is TargetInvocationException && ex.InnerException != null) {
        return InferUseCaseIdByException(ex.InnerException);
      }

      // 'Zwiebel' durch Task.Run (InnerException ist mehr repräsentativ)

      if (ex is AggregateException) {
        AggregateException castedAggregateException = (AggregateException)ex;
        if (
          castedAggregateException.InnerExceptions != null &&
          castedAggregateException.InnerExceptions.Count == 1 //falls nur 1 enthalten (macht MS gern)
        ) {
          return InferUseCaseIdByException(castedAggregateException.InnerExceptions[0]);
        }
      }

      // An einer Win32Exception hängt i.d.R. bereits eine useCaseId => diese verwenden

      if (ex is Win32Exception) {
        return ((Win32Exception)ex).NativeErrorCode;
      }

      // Falls der Absender die Konvention "MessageText #{useCaseId}" einhielt...

      int hashTagIndex = ex.Message.LastIndexOf('#');

      if (hashTagIndex >= 0 && int.TryParse(ex.Message.Substring(hashTagIndex + 1), out int id)) {
        return id;
      }

      // 'Zwiebel' durch Exception.Wrap (InnerException ist mehr repräsentativ)

      if (ex is ExceptionExtensions.WrappedException) {
        return InferUseCaseIdByException(ex.InnerException);
      }

      // Fallback zuletzt: Wir leiten aus dem Exception-Typ eine useCaseId ab.

      using (var md5 = MD5.Create()) {
        int hash = BitConverter.ToInt32(md5.ComputeHash(Encoding.UTF8.GetBytes(ex.GetType().Name)), 0);
        if (hash < 0) {
          return hash * -1;
        }
        return hash;
      }

    }

  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/BizLogger.cs

namespace Logging.SmartStandards {

  internal partial class BizLogger {

    public const string AudienceToken = "Biz";

    public static void Log(
      int level, string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args
    ) {

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (messageTemplate == null) messageTemplate = "";

      if (args == null) args = new object[0];

      TraceBusFeed.Instance.EmitMessage(AudienceToken, level, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void Log(
      int level, string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args
    ) {
      LogUseCaseRepository.GetUseCaseIdAndMessageTemplateByEnum(useCaseEnumElement, out int useCaseId, out string messageTemplate);
      Log(level, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, Exception ex) {

      int useCaseId = ExceptionAnalyzer.InferUseCaseIdByException(ex);

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, int useCaseId, Exception ex) {

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, useCaseId, ex);
    }

  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/BizLogger.PerLevel.cs

namespace Logging.SmartStandards {

  internal partial class BizLogger {

    public static void LogTrace(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(0, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(0, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(0, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Exception ex) {
      Log(0, sourceContext, sourceLineId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(1, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(1, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(1, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Exception ex) {
      Log(1, sourceContext, sourceLineId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(2, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(2, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(2, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Exception ex) {
      Log(2, sourceContext, sourceLineId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(3, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(3, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(3, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Exception ex) {
      Log(3, sourceContext, sourceLineId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(4, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(4, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(4, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, Exception ex) {
      Log(4, sourceContext, sourceLineId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(5, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(5, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(5, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Exception ex) {
      Log(5, sourceContext, sourceLineId, ex);
    }
  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/BizLogger.WoSourceContext.cs

namespace Logging.SmartStandards {

  internal partial class BizLogger {

    // NOTE: [MethodImpl(MethodImplOptions.NoInlining)]
    // is used to avoid wrong results from Assembly.GetCallingAssembly()

    #region MessageTemplate only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, 0, messageTemplate, args);
    }

    #endregion

    #region useCaseEnumElement only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, useCaseEnumElement, args);
    }

    #endregion

    #region Exception only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, ex);
    }

    #endregion

    #region SourceLineId and UseCaseId and MessageTemplate

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    #endregion

    #region SourceLineId and UseCaseEnumElement

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    #endregion

    #region SourceLineId and and UseCaseId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    #endregion

    #region SourceLineId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, ex);
    }

    #endregion

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/DevLogger.cs

namespace Logging.SmartStandards {

  internal partial class DevLogger {

    public const string AudienceToken = "Dev";

    public static void Log(
      int level, string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args
    ) {

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (messageTemplate == null) messageTemplate = "";

      if (args == null) args = new object[0];

      TraceBusFeed.Instance.EmitMessage(AudienceToken, level, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void Log(
      int level, string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args
    ) {
      LogUseCaseRepository.GetUseCaseIdAndMessageTemplateByEnum(useCaseEnumElement, out int useCaseId, out string messageTemplate);
      Log(level, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, Exception ex) {

      int useCaseId = ExceptionAnalyzer.InferUseCaseIdByException(ex);

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, int useCaseId, Exception ex) {

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, useCaseId, ex);
    }

  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/DevLogger.PerLevel.cs

namespace Logging.SmartStandards {

  internal partial class DevLogger {

    public static void LogTrace(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(0, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(0, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(0, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Exception ex) {
      Log(0, sourceContext, sourceLineId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(1, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(1, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(1, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Exception ex) {
      Log(1, sourceContext, sourceLineId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(2, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(2, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(2, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Exception ex) {
      Log(2, sourceContext, sourceLineId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(3, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(3, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(3, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Exception ex) {
      Log(3, sourceContext, sourceLineId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(4, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(4, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(4, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, Exception ex) {
      Log(4, sourceContext, sourceLineId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(5, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(5, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(5, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Exception ex) {
      Log(5, sourceContext, sourceLineId, ex);
    }
  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/DevLogger.WoSourceContext.cs

namespace Logging.SmartStandards {

  internal partial class DevLogger {

    // NOTE: [MethodImpl(MethodImplOptions.NoInlining)]
    // is used to avoid wrong results from Assembly.GetCallingAssembly()

    #region MessageTemplate only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, 0, messageTemplate, args);
    }

    #endregion

    #region useCaseEnumElement only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, useCaseEnumElement, args);
    }

    #endregion

    #region Exception only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, ex);
    }

    #endregion

    #region SourceLineId and UseCaseId and MessageTemplate

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    #endregion

    #region SourceLineId and UseCaseEnumElement

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    #endregion

    #region SourceLineId and and UseCaseId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    #endregion

    #region SourceLineId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, ex);
    }

    #endregion

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/InsLogger.cs

namespace Logging.SmartStandards {

  internal partial class InsLogger {

    public const string AudienceToken = "Ins";

    public static void Log(
      int level, string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args
    ) {

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (messageTemplate == null) messageTemplate = "";

      if (args == null) args = new object[0];

      TraceBusFeed.Instance.EmitMessage(AudienceToken, level, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void Log(
      int level, string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args
    ) {
      LogUseCaseRepository.GetUseCaseIdAndMessageTemplateByEnum(useCaseEnumElement, out int useCaseId, out string messageTemplate);
      Log(level, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, Exception ex) {

      int useCaseId = ExceptionAnalyzer.InferUseCaseIdByException(ex);

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, int useCaseId, Exception ex) {

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, useCaseId, ex);
    }

  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/InsLogger.PerLevel.cs

namespace Logging.SmartStandards {

  internal partial class InsLogger {

    public static void LogTrace(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(0, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(0, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(0, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Exception ex) {
      Log(0, sourceContext, sourceLineId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(1, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(1, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(1, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Exception ex) {
      Log(1, sourceContext, sourceLineId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(2, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(2, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(2, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Exception ex) {
      Log(2, sourceContext, sourceLineId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(3, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(3, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(3, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Exception ex) {
      Log(3, sourceContext, sourceLineId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(4, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(4, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(4, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, Exception ex) {
      Log(4, sourceContext, sourceLineId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      Log(5, sourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      Log(5, sourceContext, sourceLineId, useCaseEnumElement, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int useCaseId, Exception ex) {
      Log(5, sourceContext, sourceLineId, useCaseId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Exception ex) {
      Log(5, sourceContext, sourceLineId, ex);
    }
  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/InsLogger.WoSourceContext.cs

namespace Logging.SmartStandards {

  internal partial class InsLogger {

    // NOTE: [MethodImpl(MethodImplOptions.NoInlining)]
    // is used to avoid wrong results from Assembly.GetCallingAssembly()

    #region MessageTemplate only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, 0, messageTemplate, args);
    }

    #endregion

    #region useCaseEnumElement only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, useCaseEnumElement, args);
    }

    #endregion

    #region Exception only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogTrace(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogDebug(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogInformation(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogWarning(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogError(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      LogCritical(currentSourceContext, 0, ex);
    }

    #endregion

    #region SourceLineId and UseCaseId and MessageTemplate

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int useCaseId, string messageTemplate, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, useCaseId, messageTemplate, args);
    }

    #endregion

    #region SourceLineId and UseCaseEnumElement

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Enum useCaseEnumElement, params object[] args) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, useCaseEnumElement, args);
    }

    #endregion

    #region SourceLineId and and UseCaseId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int useCaseId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, useCaseId, ex);
    }

    #endregion

    #region SourceLineId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(0, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(1, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(2, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(3, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(4, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Exception ex) {
      string currentSourceContext = Assembly.GetCallingAssembly().GetName().Name;
      Log(5, currentSourceContext, sourceLineId, ex);
    }

    #endregion

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/ExceptionExtensions.cs

namespace Logging.SmartStandards {


  internal static partial class ExceptionExtensions { // v 1.0.0

    /// <summary>
    ///   Puts your envelope exception around an exception coming from elsewhere.
    /// </summary>
    /// <param name="extendee"> The 3rd party exception (becoming the inner exception). </param>
    /// <param name="message"> Your message adding value to the 3rd party exception. </param>
    /// <returns> A new WrappedException instance containing the extendee as inner exception. </returns>
    /// <remarks>
    ///   Purpose: The 3rd party exception might be generic (like null reference, etc.) and thus not very helpful.
    ///   Add specific information (like IDs etc.) in to the envelope's message.
    /// </remarks>
    public static Exception Wrap(this Exception extendee, string message) { // REQ #395397931

      WrappedException wrappedException = new WrappedException(message, extendee);

      return wrappedException;
    }

    /// <summary>
    ///   Puts your envelope exception around an exception coming from elsewhere.
    /// </summary>
    /// <param name="extendee"> The 3rd party exception (becoming the inner exception). </param>
    /// <param name="useCaseId"> Will be added as #-suffix to the message (SmartStandards compliant parsable). </param>
    /// <param name="message"> Your message adding value to the 3rd party exception. </param>
    /// <returns> A new WrappedException instance containing the extendee as inner exception. </returns>
    /// <remarks>
    ///   Purpose: The 3rd party exception might be generic (like null reference, etc.) and thus not very helpful.
    ///   Add specific information (like IDs etc.) in to the envelope's message.
    /// </remarks>
    public static Exception Wrap(this Exception extendee, int useCaseId, string message) { // REQ #395397931

      WrappedException wrappedException = new WrappedException(message + " #" + useCaseId.ToString(), extendee);

      return wrappedException;
    }

    internal partial class WrappedException : Exception {

      public WrappedException(string message, Exception inner) : base(message, inner) {
      }

    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/UseCaseManagement/LogMessageTemplateAttribute.cs

namespace Logging.SmartStandards.UseCaseManagement {

  /// <summary>
  ///   Defines a log message template per enum value (for LogUseCase enums).
  /// </summary>
  [AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
  internal partial class LogMessageTemplateAttribute : Attribute { // v 1.0.0

    /// <summary>
    ///  Constructor.
    /// </summary>
    /// <param name="logMessageTemplate"></param>
    /// <param name="language"> ISO code like 'en-us' or 'de-de' </param>
    public LogMessageTemplateAttribute(string logMessageTemplate, string language = null) {
      this.LogMessageTemplate = logMessageTemplate;
      this.Language = language;
    }

    public string LogMessageTemplate { get; }

    public string Language { get; }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/UseCaseManagement/LogUseCaseEnumConverter.cs

namespace Logging.SmartStandards.UseCaseManagement {

  internal partial class LogUseCaseEnumConverter : EnumConverter { // v 1.0.0

    private Array _FlagValues;

    private bool _IsFlagEnum = false;

    private Dictionary<CultureInfo, Dictionary<string, object>> _CachesPerLanguage = new Dictionary<CultureInfo, Dictionary<string, object>>();

    public LogUseCaseEnumConverter(Type enumType) : base(enumType) {
      if (enumType.GetCustomAttributes(typeof(FlagsAttribute), true).Any()) {
        _IsFlagEnum = true;
        _FlagValues = Enum.GetValues(enumType);
      }
    }

    public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

      if (value is string) {
        object result;

        if (_IsFlagEnum) {
          result = this.GetMessageTemplateFromAttributeByEnumFlag(culture, (string)value);
        } else {
          result = this.GetMessageTemplateFromCache(culture, (string)value);
        }

        if (result == null) {
          if (value != null) {
            result = base.ConvertFrom(context, culture, value);
          }
        }

        return result;
      }

      return base.ConvertFrom(context, culture, value);
    }

    public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {

      // at system.xaml.dll

      if (context == null || !(context.GetType().FullName.Equals("System.Windows.Markup.IValueSerializerContext"))) {
        if ((value != null) && (destinationType.Equals(typeof(System.String)))) {
          object result;
          if ((_IsFlagEnum)) {
            result = this.GetMessageTemplateFromAttributeByEnumFlagValue(culture, value);
          } else {
            result = this.GetMessageTemplateFromAttributeByEnumValue(culture, value);
          }
          return result;
        }
      }

      return base.ConvertTo(context, culture, value, destinationType);
    }

    public static string ConvertToString(Enum value) {
      if (value != null) {
        TypeConverter converter = TypeDescriptor.GetConverter(value.GetType());
        return converter.ConvertToString(value);
      }
      return string.Empty;
    }

    private object GetMessageTemplateFromAttributeByEnumFlag(CultureInfo culture, string text) {
      Dictionary<string, object> languageSpecificCache = this.GetLanguageSpecificCache(culture);
      string[] textValues = text.Split(',');
      ulong result = 0;

      foreach (string textValue in textValues) {
        object value = null;
        string trimmedTextValue = textValue.Trim();

        if ((!languageSpecificCache.TryGetValue(trimmedTextValue, out value)))
          return null;

        result = result | Convert.ToUInt32(value);
      }

      return Enum.ToObject(this.EnumType, result);
    }

    private Dictionary<string, object> GetLanguageSpecificCache(CultureInfo culture) {
      lock (_CachesPerLanguage) {
        Dictionary<string, object> result = null;
        if (culture == null) {
          culture = CultureInfo.CurrentCulture;
        }
        if (!_CachesPerLanguage.TryGetValue(culture, out result)) {
          result = new Dictionary<string, object>();
          foreach (var value in this.GetStandardValues()) {
            var text = this.GetMessageTemplateFromAttributeByEnumValue(culture, value);
            if (text != null) {
              result.Add(text, value);
            }
          }
          _CachesPerLanguage.Add(culture, result);
        }
        return result;
      }
    }

    private object GetMessageTemplateFromCache(CultureInfo culture, string text) {
      Dictionary<string, object> languageSpecificCache = this.GetLanguageSpecificCache(culture);
      object result = null;
      languageSpecificCache.TryGetValue(text, out result);
      return result;
    }

    private string GetMessageTemplateFromAttributeByEnumValue(CultureInfo culture, object value) {

      if (value == null) {
        return string.Empty;
      }

      Type type = value.GetType();

      if (!type.IsEnum) {
        return value.ToString();
      }

      LogMessageTemplateAttribute[] attributes = this.GetEnumFieldAttributes<LogMessageTemplateAttribute>((Enum)value);

      LogMessageTemplateAttribute defaultAttribute = attributes.FirstOrDefault();

      foreach (LogMessageTemplateAttribute attribute in attributes) {
        if (string.IsNullOrEmpty(attribute.Language)) {
          defaultAttribute = attribute;
        } else if (attribute.Language.Equals(culture.Name, StringComparison.InvariantCultureIgnoreCase)) {
          return attribute.LogMessageTemplate;
        }
      }
      if (defaultAttribute != null) {
        return defaultAttribute.LogMessageTemplate;
      } else {
        return Enum.GetName(type, value);
      }
    }

    private string GetMessageTemplateFromAttributeByEnumFlagValue(CultureInfo culture, object value) {
      if (Enum.IsDefined(value.GetType(), value)) {
        return this.GetMessageTemplateFromAttributeByEnumValue(culture, value);
      }
      long lValue = Convert.ToInt32(value);
      string result = null;
      foreach (object flagValue in _FlagValues) {
        long lFlagValue = Convert.ToInt32(flagValue);
        if (this.CheckSingleBit(lFlagValue)) {
          if ((lFlagValue & lValue) == lFlagValue) {
            string valueText = this.GetMessageTemplateFromAttributeByEnumValue(culture, flagValue);
            if (result == null) {
              result = valueText;
            } else {
              result = string.Format("{0}+{1}", result, valueText);
            }
          }
        }
      }

      return result;
    }

    public static List<KeyValuePair<Enum, string>> GetValues(Type enumType) {
      return GetValues(enumType, CultureInfo.CurrentUICulture);
    }

    public static List<KeyValuePair<Enum, string>> GetValues(Type enumType, CultureInfo culture) {
      List<KeyValuePair<Enum, string>> result = new List<KeyValuePair<Enum, string>>();
      TypeConverter converter = TypeDescriptor.GetConverter(enumType);
      foreach (System.Enum value in Enum.GetValues(enumType)) {
        KeyValuePair<Enum, string> pair = new KeyValuePair<Enum, string>(
          value, converter.ConvertToString(null, culture, value)
        );
        result.Add(pair);
      }
      return result;
    }

    private bool CheckSingleBit(long value) {
      switch (value) {
        case 0: {
          return false;
        }
        case 1: {
          return true;
        }
      }
      return ((value & (value - 1)) == 0);
    }

    private TAttribute[] GetEnumFieldAttributes<TAttribute>(Enum enumValue) where TAttribute : Attribute {
      Type enumType = enumValue.GetType();
      string enumFieldName = Enum.GetName(enumType, enumValue);
      if ((enumFieldName == null))
        return new TAttribute[] { };
      else {
        FieldInfo enumField = enumType.GetField(enumFieldName);
        return enumField.GetCustomAttributes(false).OfType<TAttribute>().ToArray();
      }
    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/UseCaseManagement/LogUseCaseRepository.cs

namespace Logging.SmartStandards.UseCaseManagement {


  internal static partial class LogUseCaseRepository { // v 1.0.0

    internal static void GetUseCaseIdAndMessageTemplateByEnum(Enum useCaseEnumElement, out int useCaseId, out string messageTemplate) {

      useCaseId = (int)(object)useCaseEnumElement;

      messageTemplate = null;

      try {
        TypeConverter typeConverter = TypeDescriptor.GetConverter(useCaseEnumElement);
        if (typeConverter != null && typeConverter.CanConvertTo(typeof(System.String))) {
          messageTemplate = typeConverter.ConvertToString(useCaseEnumElement);
        }
      } catch {
      }
      if (String.IsNullOrWhiteSpace(messageTemplate)) {
        messageTemplate = Enum.GetName(useCaseEnumElement.GetType(), useCaseEnumElement);
      }
    }

  }
}

